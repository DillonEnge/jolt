// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: messages.sql

package database

import (
	"context"
)

const messagesByNegotiationID = `-- name: MessagesByNegotiationID :many
SELECT m.id, m.negotiation_id, m.sender_email, m.sender_name, m.message_text, m.time_sent, m.status FROM messages m
LEFT JOIN negotiations n ON m.negotiation_id = n.id
WHERE n.id = $1::text
`

func (q *Queries) MessagesByNegotiationID(ctx context.Context, negotiationID string) ([]Message, error) {
	rows, err := q.db.Query(ctx, messagesByNegotiationID, negotiationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.NegotiationID,
			&i.SenderEmail,
			&i.SenderName,
			&i.MessageText,
			&i.TimeSent,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordMessage = `-- name: RecordMessage :one
INSERT INTO messages(id, negotiation_id, sender_email, sender_name, message_text)
VALUES(
    uuid_generate_v4(),
    $1::text,
    $2::text,
    $3::text,
    $4::text
)
ON CONFLICT(id) DO UPDATE SET
    message_text = excluded.message_text,
    status = excluded.status
RETURNING id, negotiation_id, sender_email, sender_name, message_text, time_sent, status
`

type RecordMessageParams struct {
	NegotiationID string `json:"negotiation_id"`
	SenderEmail   string `json:"sender_email"`
	SenderName    string `json:"sender_name"`
	MessageText   string `json:"message_text"`
}

func (q *Queries) RecordMessage(ctx context.Context, arg RecordMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, recordMessage,
		arg.NegotiationID,
		arg.SenderEmail,
		arg.SenderName,
		arg.MessageText,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.NegotiationID,
		&i.SenderEmail,
		&i.SenderName,
		&i.MessageText,
		&i.TimeSent,
		&i.Status,
	)
	return i, err
}
