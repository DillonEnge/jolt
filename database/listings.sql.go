// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: listings.sql

package database

import (
	"context"
)

const deleteListing = `-- name: DeleteListing :one
DELETE FROM listings l
WHERE l.id = $1::text
RETURNING id, name, description, price, seller_email
`

func (q *Queries) DeleteListing(ctx context.Context, listingID string) (Listing, error) {
	row := q.db.QueryRow(ctx, deleteListing, listingID)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.SellerEmail,
	)
	return i, err
}

const listingByID = `-- name: ListingByID :one
SELECT l.id, l.name, l.description, l.price, l.seller_email, l.image_urls
FROM listing_with_image_urls l
WHERE l.id = $1::text
`

func (q *Queries) ListingByID(ctx context.Context, listingID string) (ListingWithImageUrl, error) {
	row := q.db.QueryRow(ctx, listingByID, listingID)
	var i ListingWithImageUrl
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.SellerEmail,
		&i.ImageUrls,
	)
	return i, err
}

const listingsByLikeName = `-- name: ListingsByLikeName :many
SELECT l.id, l.name, l.description, l.price, l.seller_email, l.image_urls
FROM listing_with_image_urls l
WHERE UPPER(l.name) LIKE UPPER('%' || $1::text || '%')
`

func (q *Queries) ListingsByLikeName(ctx context.Context, listingName string) ([]ListingWithImageUrl, error) {
	rows, err := q.db.Query(ctx, listingsByLikeName, listingName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingWithImageUrl
	for rows.Next() {
		var i ListingWithImageUrl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.SellerEmail,
			&i.ImageUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listingsBySellerEmail = `-- name: ListingsBySellerEmail :many
SELECT l.id, l.name, l.description, l.price, l.seller_email, l.image_urls
FROM listing_with_image_urls l
WHERE UPPER(l.seller_email) = UPPER($1::text)
`

func (q *Queries) ListingsBySellerEmail(ctx context.Context, sellerEmail string) ([]ListingWithImageUrl, error) {
	rows, err := q.db.Query(ctx, listingsBySellerEmail, sellerEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingWithImageUrl
	for rows.Next() {
		var i ListingWithImageUrl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.SellerEmail,
			&i.ImageUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listingsByViews = `-- name: ListingsByViews :many
SELECT l.id, l.name, l.description, l.price, l.seller_email, l.image_urls
FROM listing_with_image_urls l
JOIN listing_views lv ON lv.listing_id = l.id
ORDER BY lv.views DESC
LIMIT $1
OFFSET $2
`

type ListingsByViewsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListingsByViews(ctx context.Context, arg ListingsByViewsParams) ([]ListingWithImageUrl, error) {
	rows, err := q.db.Query(ctx, listingsByViews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingWithImageUrl
	for rows.Next() {
		var i ListingWithImageUrl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.SellerEmail,
			&i.ImageUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordListing = `-- name: RecordListing :one
INSERT INTO listings(id, seller_email, name, description, price) VALUES(
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5::int
)
RETURNING id, name, description, price, seller_email
`

type RecordListingParams struct {
	ID          string `json:"id"`
	SellerEmail string `json:"seller_email"`
	ListingName string `json:"listing_name"`
	Description string `json:"description"`
	Price       int32  `json:"price"`
}

func (q *Queries) RecordListing(ctx context.Context, arg RecordListingParams) (Listing, error) {
	row := q.db.QueryRow(ctx, recordListing,
		arg.ID,
		arg.SellerEmail,
		arg.ListingName,
		arg.Description,
		arg.Price,
	)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.SellerEmail,
	)
	return i, err
}

const recordListingImages = `-- name: RecordListingImages :many
INSERT INTO listing_images(listing_id, image_url) VALUES(
    $1::text,
    unnest($2::text[])
)
RETURNING listing_id, image_url
`

type RecordListingImagesParams struct {
	ListingID     string   `json:"listing_id"`
	ImageUrlArray []string `json:"image_url_array"`
}

func (q *Queries) RecordListingImages(ctx context.Context, arg RecordListingImagesParams) ([]ListingImage, error) {
	rows, err := q.db.Query(ctx, recordListingImages, arg.ListingID, arg.ImageUrlArray)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingImage
	for rows.Next() {
		var i ListingImage
		if err := rows.Scan(&i.ListingID, &i.ImageUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
