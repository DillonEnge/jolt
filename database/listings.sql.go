// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: listings.sql

package database

import (
	"context"
)

const deleteListing = `-- name: DeleteListing :one
DELETE FROM listings l
WHERE l.id = $1::text
RETURNING id, name, description, price, seller_email
`

func (q *Queries) DeleteListing(ctx context.Context, listingID string) (Listing, error) {
	row := q.db.QueryRow(ctx, deleteListing, listingID)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.SellerEmail,
	)
	return i, err
}

const listingByID = `-- name: ListingByID :many
SELECT l.id, l.name, l.description, l.price, l.seller_email
FROM listings l
WHERE l.id = $1::text
`

func (q *Queries) ListingByID(ctx context.Context, listingID string) ([]Listing, error) {
	rows, err := q.db.Query(ctx, listingByID, listingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Listing
	for rows.Next() {
		var i Listing
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.SellerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listingsByLikeName = `-- name: ListingsByLikeName :many
SELECT l.id, l.name, l.description, l.price, l.seller_email
FROM listings l
WHERE UPPER(l.name) LIKE UPPER('%' || $1::text || '%')
`

func (q *Queries) ListingsByLikeName(ctx context.Context, listingName string) ([]Listing, error) {
	rows, err := q.db.Query(ctx, listingsByLikeName, listingName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Listing
	for rows.Next() {
		var i Listing
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.SellerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listingsBySellerEmail = `-- name: ListingsBySellerEmail :many
SELECT l.id, l.name, l.description, l.price, l.seller_email
FROM listings l
WHERE UPPER(l.seller_email) = UPPER($1::text)
`

func (q *Queries) ListingsBySellerEmail(ctx context.Context, sellerEmail string) ([]Listing, error) {
	rows, err := q.db.Query(ctx, listingsBySellerEmail, sellerEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Listing
	for rows.Next() {
		var i Listing
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.SellerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordListing = `-- name: RecordListing :one
INSERT INTO listings(id, seller_email, name, description, price) VALUES(
    uuid_generate_v4(),
    $1::text,
    $2::text,
    $3::text,
    $4::int
)
RETURNING id, name, description, price, seller_email
`

type RecordListingParams struct {
	SellerEmail string `json:"seller_email"`
	ListingName string `json:"listing_name"`
	Description string `json:"description"`
	Price       int32  `json:"price"`
}

func (q *Queries) RecordListing(ctx context.Context, arg RecordListingParams) (Listing, error) {
	row := q.db.QueryRow(ctx, recordListing,
		arg.SellerEmail,
		arg.ListingName,
		arg.Description,
		arg.Price,
	)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.SellerEmail,
	)
	return i, err
}
